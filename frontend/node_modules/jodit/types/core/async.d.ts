/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Released under MIT see LICENSE.txt in the project root for license information.
 * Copyright (c) 2013-2021 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
import type { CallbackFunction, IAsync, IAsyncParams, ITimeout, RejectablePromise } from '../types';
export declare class Async implements IAsync {
    private timers;
    delay(timeout: number | IAsyncParams): RejectablePromise<void>;
    setTimeout(callback: (...args: any[]) => void, timeout: number | IAsyncParams, ...args: any[]): number;
    private clearLabel;
    clearTimeout(timer: number): void;
    clearTimeout(label: string): void;
    /**
     * Debouncing enforces that a function not be called again until a certain amount of time has passed without
     * it being called. As in "execute this function only if 100 milliseconds have passed without it being called."
     *
     * @example
     * ```javascript
     * var jodit = new Jodit('.editor');
     *	jodit.e.on('mousemove', jodit.async.debounce(function() {
     *     // Do expensive things
     * }, 100));
     * ```
     *
     */
    debounce(fn: CallbackFunction, timeout: ITimeout | IAsyncParams, firstCallImmediately?: boolean): CallbackFunction;
    /**
     * Throttling enforces a maximum number of times a function can be called over time.
     * As in "execute this function at most once every 100 milliseconds."
     *
     * @example
     * ```javascript
     * var jodit = new Jodit('.editor');
     * jodit.e.on(document.body, 'scroll', jodit.async.throttle(function() {
     *     // Do expensive things
     * }, 100));
     * ```
     */
    throttle(fn: CallbackFunction, timeout: ITimeout | IAsyncParams, ignore?: boolean): CallbackFunction;
    private promisesRejections;
    promise<T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): RejectablePromise<T>;
    /**
     * Get Promise status
     */
    promiseState(p: Promise<any>): Promise<'pending' | 'fulfilled' | 'rejected'>;
    private requestsIdle;
    private requestIdleCallbackNative;
    private cancelIdleCallbackNative;
    requestIdleCallback(callback: IdleRequestCallback): number;
    requestIdlePromise(): RejectablePromise<number>;
    cancelIdleCallback(request: number): void;
    clear(): void;
    isDestructed: boolean;
    destruct(): any;
}
